#! /bin/sh /usr/share/dpatch/dpatch-run
## opt-21_sourcecaps.dpatch by Christian Schuld <chris@sonnengesicht.de>
## http://linvdr.org/mailinglists/vdr/2004/08/msg00521.html
## http://article.gmane.org/gmane.linux.vdr/27260/
##
## Thomas Günther <tom@toms-cafe.de>:
##   - adapted to VDR-1.5.0
## Tobias Grimm <tg@e-tobi.net>:
##   - adapted to VDR-1.5.16
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Patch for assigning special satellites to one dvb card.

@DPATCH@
diff -p -up vdr-1.6.0/config.c.orig vdr-1.6.0/config.c
--- vdr-1.6.0/config.c.orig	2009-03-20 23:52:46.000000000 +0200
+++ vdr-1.6.0/config.c	2009-03-20 23:52:47.000000000 +0200
@@ -15,6 +15,7 @@
 #include "interface.h"
 #include "plugin.h"
 #include "recording.h"
+#include "sources.h"
 
 // IMPORTANT NOTE: in the 'sscanf()' calls there is a blank after the '%d'
 // format characters in order to allow any number of blanks after a numeric
@@ -229,6 +230,8 @@ cSetup::cSetup(void)
   LnbFrequLo =  9750;
   LnbFrequHi = 10600;
   DiSEqC = 0;
+  memset(SourceCaps, 0, sizeof SourceCaps);
+  SourceCapsSet = false;
   SetSystemTime = 0;
   TimeSource = 0;
   TimeTransponder = 0;
@@ -391,6 +394,49 @@ bool cSetup::ParseLanguages(const char *
   return true;
 }
 
+void cSetup::StoreSourceCaps(const char *Name)
+{
+  cSetupLine *l;
+  while ((l = Get(Name)) != NULL)
+        Del(l);
+
+  for (int i = 0; i < MAXDEVICES; i++) {
+      char buffer[MAXSOURCECAPS*8]={0,}, *q = buffer;
+      int j = 0;
+      while (SourceCaps[i][j] && j < MAXSOURCECAPS) {
+            if (j==0) 
+               q += snprintf(buffer, sizeof(buffer), "%i ", i+1);
+            q += snprintf(q, sizeof(buffer) - (q-buffer), "%s ", *cSource::ToString(SourceCaps[i][j++]));
+      }
+      if (*buffer)
+         Store(Name, buffer, NULL, true);
+      }
+}
+
+bool cSetup::ParseSourceCaps(const char *Value)
+{
+  char *p;
+  int d = strtol(Value, &p, 10)-1, i = 0;
+  while (p < Value+strlen(Value)) {
+        if (*p==0) return true;
+        if (isblank(*p)) ++p;
+        if (isalpha(*p)) {
+           int source = cSource::FromString(p);
+           if (source != cSource::stNone) {
+              SourceCaps[d][i++] = source;
+              SourceCapsSet = true;
+              }
+           else
+              return false;
+           while (!isblank(*p) && *p)
+                 ++p;
+           if (i>MAXSOURCECAPS)
+              return false;
+           }
+        }
+  return true;
+}
+
 bool cSetup::Parse(const char *Name, const char *Value)
 {
   if      (!strcasecmp(Name, "OSDLanguage"))       { strn0cpy(OSDLanguage, Value, sizeof(OSDLanguage)); I18nSetLocale(OSDLanguage); }
@@ -409,6 +455,7 @@ bool cSetup::Parse(const char *Name, con
   else if (!strcasecmp(Name, "LnbFrequLo"))          LnbFrequLo         = atoi(Value);
   else if (!strcasecmp(Name, "LnbFrequHi"))          LnbFrequHi         = atoi(Value);
   else if (!strcasecmp(Name, "DiSEqC"))              DiSEqC             = atoi(Value);
+  else if (!strcasecmp(Name, "SourceCaps"))          return ParseSourceCaps(Value);
   else if (!strcasecmp(Name, "SetSystemTime"))       SetSystemTime      = atoi(Value);
   else if (!strcasecmp(Name, "TimeSource"))          TimeSource         = cSource::FromString(Value);
   else if (!strcasecmp(Name, "TimeTransponder"))     TimeTransponder    = atoi(Value);
@@ -498,6 +545,7 @@ bool cSetup::Save(void)
   Store("LnbFrequLo",         LnbFrequLo);
   Store("LnbFrequHi",         LnbFrequHi);
   Store("DiSEqC",             DiSEqC);
+  if (SourceCapsSet) StoreSourceCaps("SourceCaps");
   Store("SetSystemTime",      SetSystemTime);
   Store("TimeSource",         cSource::ToString(TimeSource));
   Store("TimeTransponder",    TimeTransponder);
diff -p -up vdr-1.6.0/config.h.orig vdr-1.6.0/config.h
--- vdr-1.6.0/config.h.orig	2009-03-20 23:52:46.000000000 +0200
+++ vdr-1.6.0/config.h	2009-03-20 23:52:47.000000000 +0200
@@ -50,6 +50,9 @@
 #define MINOSDHEIGHT 324
 #define MAXOSDHEIGHT 567
 
+#define MAXDEVICES         16 // the maximum number of devices in the system
+#define MAXSOURCECAPS     128 // the maximum number of different sources per device
+
 #define MaxFileName 256
 #define MaxSkinName 16
 #define MaxThemeName 16
@@ -199,6 +202,8 @@ private:
   void StoreLanguages(const char *Name, int *Values);
   bool ParseLanguages(const char *Value, int *Values);
   bool Parse(const char *Name, const char *Value);
+  void StoreSourceCaps(const char *Name);
+  bool ParseSourceCaps(const char *Value);
   cSetupLine *Get(const char *Name, const char *Plugin = NULL);
   void Store(const char *Name, const char *Value, const char *Plugin = NULL, bool AllowMultiple = false);
   void Store(const char *Name, int Value, const char *Plugin = NULL);
@@ -221,6 +226,8 @@ public:
   int LnbFrequLo;
   int LnbFrequHi;
   int DiSEqC;
+  int SourceCaps[MAXDEVICES][MAXSOURCECAPS];
+  bool SourceCapsSet;
   int SetSystemTime;
   int TimeSource;
   int TimeTransponder;
diff -p -up vdr-1.6.0/device.c.orig vdr-1.6.0/device.c
--- vdr-1.6.0/device.c.orig	2009-03-20 23:52:46.000000000 +0200
+++ vdr-1.6.0/device.c	2009-03-20 23:52:47.000000000 +0200
@@ -256,8 +256,10 @@ cDevice::cDevice(void)
   for (int i = 0; i < MAXRECEIVERS; i++)
       receiver[i] = NULL;
 
-  if (numDevices < MAXDEVICES)
+  if (numDevices < MAXDEVICES) {
      device[numDevices++] = this;
+     SetSourceCaps(cardIndex);
+     }
   else
      esyslog("ERROR: too many devices!");
 }
@@ -472,6 +474,17 @@ void cDevice::SetCamSlot(cCamSlot *CamSl
   camSlot = CamSlot;
 }
 
+void cDevice::SetSourceCaps(int Index)
+{
+  for (int d = 0; d < numDevices; d++) {
+      if (Index < 0 || Index == device[d]->CardIndex()) {
+         for (int i = 0; i < MAXSOURCECAPS; i++)
+             device[d]->sourceCaps[i] = Setup.SourceCaps[device[d]->CardIndex()][i];
+         }
+      }
+}
+
+
 void cDevice::Shutdown(void)
 {
   primaryDevice = NULL;
diff -p -up vdr-1.6.0/device.h.orig vdr-1.6.0/device.h
--- vdr-1.6.0/device.h.orig	2009-03-20 23:52:46.000000000 +0200
+++ vdr-1.6.0/device.h	2009-03-20 23:52:47.000000000 +0200
@@ -24,7 +24,6 @@
 #include "thread.h"
 #include "tools.h"
 
-#define MAXDEVICES         16 // the maximum number of devices in the system
 #define MAXPIDHANDLES      64 // the maximum number of different PIDs per device
 #define MAXRECEIVERS       16 // the maximum number of receivers per device
 #define MAXVOLUME         255
@@ -159,6 +158,8 @@ public:
   static void SetAvoidDevice(cDevice *Device) { avoidDevice = Device; }
          ///< Sets the given Device to be temporarily avoided in the next call to
          ///< GetDevice(const cChannel, int, bool).
+  static void SetSourceCaps(int Index = -1);
+         ///< Sets the SourceCaps of the given device according to the Setup data.
   static void Shutdown(void);
          ///< Closes down all devices.
          ///< Must be called at the end of the program.
@@ -166,6 +167,7 @@ private:
   static int nextCardIndex;
   int cardIndex;
 protected:
+  int sourceCaps[MAXSOURCECAPS];
   cDevice(void);
   virtual ~cDevice();
   virtual bool Ready(void);
diff -p -up vdr-1.6.0/dvbdevice.c.orig vdr-1.6.0/dvbdevice.c
--- vdr-1.6.0/dvbdevice.c.orig	2009-03-20 23:52:46.000000000 +0200
+++ vdr-1.6.0/dvbdevice.c	2009-03-20 23:52:47.000000000 +0200
@@ -756,6 +756,12 @@ void cDvbDevice::TurnOffLiveMode(bool Li
 bool cDvbDevice::ProvidesSource(int Source) const
 {
   int type = Source & cSource::st_Mask;
+  if (Setup.SourceCapsSet && type == cSource::stSat && frontendType == FE_QPSK) {
+     for (int i = 0; i < MAXSOURCECAPS; i++)
+         if (sourceCaps[i] == Source)
+            return true;
+     return false;
+     }
   return type == cSource::stNone
       || type == cSource::stCable && frontendType == FE_QAM
       || type == cSource::stSat   && frontendType == FE_QPSK
diff -p -up vdr-1.6.0/sources.c.orig vdr-1.6.0/sources.c
--- vdr-1.6.0/sources.c.orig	2009-03-20 23:52:46.000000000 +0200
+++ vdr-1.6.0/sources.c	2009-03-20 23:52:47.000000000 +0200
@@ -70,7 +70,7 @@ int cSource::FromString(const char *s)
      int pos = 0;
      bool dot = false;
      bool neg = false;
-     while (*++s) {
+     while (*++s && !isblank(*s)) {
            switch (toupper(*s)) {
              case '0' ... '9': pos *= 10;
                                pos += *s - '0';
